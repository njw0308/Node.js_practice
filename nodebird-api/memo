Api? 남이 만들어 놓은 서버쪽 코드를 사용할 수 있는 창구

서버를 여러 개로 분리해서 하나가 터져도 작동을 하게끔.
--> 장점만 있는 것은 아님. 너무 잘게 쪼개면 어디서 에러가 났는지 모름. 로그 분석

여러 개의 서버를 동시에 띄우는 작업을 해볼 것임.

1. npm i uuid --> 고유 식별자를 만들기 위해. 

2. npm i jsonwebtoken --> 토큰을 만들어주는 패키지. jwt는 프론트나 서버 둘 다에서 인증 용도로 사용가능.
   --> jwt 토큰은 jwt 비밀키를 알지 않는 이상 변조 불가능. 번조한 토큰은 '시그니처'를 검사할 때 들통난다.
   --> 일단 프론트에서 보여지는 순간, 그것은 해커가 털 수 있다고 보면 됨. 
   --> 우리가 만든 clientSecret 은 프론트에서 사용 불가.
   장점 : 사용자 이름, 권한 같은 것을 넣어두고 안심해서 사용해도 됨.
   단점 : 용량이 큼. 내용물이 들어이 있기 때문에 랜덤토큰에 비해 용량이 크다. ( 매 요청이 토큰이 오고가기 때문)

라우터의 이름이 v1 인 이유 
--> 한 번 버전이 정해진 후에 라우터를 함부로 수정하면 안됨. 다른 사람이 기존 API 를 쓰고 있음을 염두
--> 버전을 올린 라우터를 새로 추가하고, 이전 API 사용자에게 새로운 API가 나왔음을 알리는 것이 좋다.

-----------------------------------
복습 :
쿠기? 우리가 누구인지 기억하기 위해, 요청에 대한 응답을 할 때 쿠키라는 것을 같이 보냄. '키-값'의 쌍.
      --> 서버에서 쿠키가 오면 웹 브라우저는 쿠키를 저장해둔다.( 최초로 브라우저에 쿠키를 심는 과정)
      --> 나중에 요청할 때 쿠키를 동봉해서 같이 보내줌. 
      --> 서버는 쿠키를 읽어 사용자가 누구인지 파악.

app.use(cookieParser('secret code'));
--> 제공된 문자열로 서명된 쿠키가 됨.
app.use(session({
    resave : false,  --> 요청이 왔을 때 세션에 수정사항이 생기지 않더라도 세션을 다시 저장할지에 대한 설정
    saveinitialized: false, --> 세션에 저장할 내역이 없더라도 세션을 저장할지에 대한 설정 (방문자 추석지 사용)
    secret: 'secret code', --> [필수 항목] / cookie-parser 의 비밀키와 같은 역할.
    cooke: { --> 일반적인 쿠키 옵션이 모두 제공.
        httpOnly: true, --> 자바스크립트에서 쿠키에 접근할 수 없음. 쿠키 조작을 방지.
        secure:false, --> Https 일 경우에만 쿠키가 전송됨
    }
}))
--> 세션 관리용 미들웨어.
--> express-session 은 클라이언트에게 쿠키를 보내는데, 이를 '세션 쿠키'라고 함.
--> 안전하게 쿠키를 전송하기 위해 쿠키에 서명을 추가해야하고, 쿠키를 서명하는데 secret의 값이 필요.
